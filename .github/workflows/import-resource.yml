name: Import Azure Resource

on:
  workflow_dispatch:
    inputs:
      resource_type:
        description: 'Tipo de recurso a importar'
        required: true
        type: choice
        options:
          - resource_group
          - virtual_network
          - subnet
          - network_security_group
          - storage_account
          - key_vault
          - virtual_machine_linux
          - virtual_machine_windows
          - network_interface
          - managed_disk
          - public_ip
          - container_registry

      resource_name:
        description: 'Nombre del recurso en Azure'
        required: true
        type: string

      resource_group:
        description: 'Resource Group donde est√° el recurso'
        required: true
        type: string

      terraform_resource_name:
        description: 'Nombre para el recurso en Terraform (ej: prod, main, web01)'
        required: true
        type: string

      branch_name:
        description: 'Rama donde se har√° el import (default: import/[resource_name])'
        required: false
        type: string
        default: ''

      use_module:
        description: '¬øUsar m√≥dulo del repositorio? (solo para VMs y recursos complejos)'
        required: false
        type: boolean
        default: false

      subscription_id:
        description: 'ID de la suscripci√≥n de Azure donde est√° el recurso'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write

env:
  TF_IN_AUTOMATION: true
  ARM_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET:   ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ inputs.subscription_id }}
  ARM_ACCESS_KEY:      ${{ secrets.ARM_ACCESS_KEY }}

jobs:
  discover:
    name: üîç Descubrir Recurso en Azure
    runs-on: ubuntu-latest
    outputs:
      resource_id: ${{ steps.discover.outputs.resource_id }}
      resource_config: ${{ steps.discover.outputs.resource_config }}
      terraform_address: ${{ steps.discover.outputs.terraform_address }}
      branch_name: ${{ steps.branch.outputs.branch_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: >
            {"clientId":"${{ secrets.AZURE_CLIENT_ID }}",
             "clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}",
             "subscriptionId":"${{ inputs.subscription_id }}",
             "tenantId":"${{ secrets.AZURE_TENANT_ID }}"}

      - name: Determinar nombre de rama
        id: branch
        run: |
          if [ -z "${{ inputs.branch_name }}" ]; then
            BRANCH="import/${{ inputs.resource_type }}-${{ inputs.terraform_resource_name }}"
          else
            BRANCH="${{ inputs.branch_name }}"
          fi
          echo "branch_name=$BRANCH" >> $GITHUB_OUTPUT
          echo "üìå Rama a usar: $BRANCH"

      - name: Descubrir recurso en Azure
        id: discover
        run: |
          echo "üîç Buscando recurso en Azure..."

          RESOURCE_TYPE="${{ inputs.resource_type }}"
          RESOURCE_NAME="${{ inputs.resource_name }}"
          RG="${{ inputs.resource_group }}"
          TF_NAME="${{ inputs.terraform_resource_name }}"

          # Funci√≥n para obtener Resource ID seg√∫n tipo
          case "$RESOURCE_TYPE" in

            resource_group)
              RESOURCE_ID=$(az group show -n "$RESOURCE_NAME" --query id -o tsv)
              TF_ADDRESS="azurerm_resource_group.${TF_NAME}"

              # Generar configuraci√≥n
              LOCATION=$(az group show -n "$RESOURCE_NAME" --query location -o tsv)
              TAGS=$(az group show -n "$RESOURCE_NAME" --query tags -o json)

              CONFIG=$(cat <<EOF
          resource "azurerm_resource_group" "$TF_NAME" {
            name     = "$RESOURCE_NAME"
            location = "$LOCATION"

            tags = $TAGS
          }
          EOF
          )
              ;;

            virtual_network)
              RESOURCE_ID=$(az network vnet show -g "$RG" -n "$RESOURCE_NAME" --query id -o tsv)
              TF_ADDRESS="azurerm_virtual_network.${TF_NAME}"

              # Generar configuraci√≥n
              VNET_DATA=$(az network vnet show -g "$RG" -n "$RESOURCE_NAME" -o json)
              LOCATION=$(echo "$VNET_DATA" | jq -r '.location')
              ADDRESS_SPACE=$(echo "$VNET_DATA" | jq -r '.addressSpace.addressPrefixes | join("\", \"")' | sed 's/^/["/;s/$/"]/')
              TAGS=$(echo "$VNET_DATA" | jq '.tags')

              CONFIG=$(cat <<EOF
          resource "azurerm_virtual_network" "$TF_NAME" {
            name                = "$RESOURCE_NAME"
            resource_group_name = "$RG"
            location            = "$LOCATION"
            address_space       = $ADDRESS_SPACE

            tags = $TAGS
          }
          EOF
          )
              ;;

            subnet)
              VNET_NAME=$(az network vnet subnet show -g "$RG" --vnet-name "${{ github.event.inputs.vnet_name }}" -n "$RESOURCE_NAME" --query "id" -o tsv | cut -d'/' -f9)
              RESOURCE_ID=$(az network vnet subnet show -g "$RG" --vnet-name "$VNET_NAME" -n "$RESOURCE_NAME" --query id -o tsv)
              TF_ADDRESS="azurerm_subnet.${TF_NAME}"

              SUBNET_DATA=$(az network vnet subnet show -g "$RG" --vnet-name "$VNET_NAME" -n "$RESOURCE_NAME" -o json)
              ADDRESS_PREFIX=$(echo "$SUBNET_DATA" | jq -r '.addressPrefix')

              CONFIG=$(cat <<EOF
          resource "azurerm_subnet" "$TF_NAME" {
            name                 = "$RESOURCE_NAME"
            resource_group_name  = "$RG"
            virtual_network_name = "$VNET_NAME"
            address_prefixes     = ["$ADDRESS_PREFIX"]
          }
          EOF
          )
              ;;

            network_security_group)
              RESOURCE_ID=$(az network nsg show -g "$RG" -n "$RESOURCE_NAME" --query id -o tsv)
              TF_ADDRESS="azurerm_network_security_group.${TF_NAME}"

              NSG_DATA=$(az network nsg show -g "$RG" -n "$RESOURCE_NAME" -o json)
              LOCATION=$(echo "$NSG_DATA" | jq -r '.location')
              TAGS=$(echo "$NSG_DATA" | jq '.tags')

              CONFIG=$(cat <<EOF
          resource "azurerm_network_security_group" "$TF_NAME" {
            name                = "$RESOURCE_NAME"
            resource_group_name = "$RG"
            location            = "$LOCATION"

            tags = $TAGS
          }

          # NOTA: Las reglas NSG se deben importar por separado
          # Para cada regla ejecuta:
          # terraform import azurerm_network_security_rule.[nombre] /subscriptions/.../networkSecurityGroups/$RESOURCE_NAME/securityRules/[rule-name]
          EOF
          )
              ;;

            storage_account)
              RESOURCE_ID=$(az storage account show -g "$RG" -n "$RESOURCE_NAME" --query id -o tsv)
              TF_ADDRESS="azurerm_storage_account.${TF_NAME}"

              SA_DATA=$(az storage account show -g "$RG" -n "$RESOURCE_NAME" -o json)
              LOCATION=$(echo "$SA_DATA" | jq -r '.location')
              SKU=$(echo "$SA_DATA" | jq -r '.sku.name')
              KIND=$(echo "$SA_DATA" | jq -r '.kind')
              TIER=$(echo "$SKU" | cut -d'_' -f1)
              REPLICATION=$(echo "$SKU" | cut -d'_' -f2)
              TAGS=$(echo "$SA_DATA" | jq '.tags')

              CONFIG=$(cat <<EOF
          resource "azurerm_storage_account" "$TF_NAME" {
            name                     = "$RESOURCE_NAME"
            resource_group_name      = "$RG"
            location                 = "$LOCATION"
            account_tier             = "$TIER"
            account_replication_type = "$REPLICATION"
            account_kind             = "$KIND"

            tags = $TAGS
          }
          EOF
          )
              ;;

            key_vault)
              RESOURCE_ID=$(az keyvault show -g "$RG" -n "$RESOURCE_NAME" --query id -o tsv)
              TF_ADDRESS="azurerm_key_vault.${TF_NAME}"

              KV_DATA=$(az keyvault show -g "$RG" -n "$RESOURCE_NAME" -o json)
              LOCATION=$(echo "$KV_DATA" | jq -r '.location')
              TENANT_ID=$(echo "$KV_DATA" | jq -r '.properties.tenantId')
              SKU=$(echo "$KV_DATA" | jq -r '.properties.sku.name')
              TAGS=$(echo "$KV_DATA" | jq '.tags')

              CONFIG=$(cat <<EOF
          data "azurerm_client_config" "current" {}

          resource "azurerm_key_vault" "$TF_NAME" {
            name                = "$RESOURCE_NAME"
            resource_group_name = "$RG"
            location            = "$LOCATION"
            tenant_id           = "$TENANT_ID"
            sku_name            = "$SKU"

            tags = $TAGS
          }
          EOF
          )
              ;;

            virtual_machine_linux|virtual_machine_windows)
              RESOURCE_ID=$(az vm show -g "$RG" -n "$RESOURCE_NAME" --query id -o tsv)

              if [ "${{ inputs.use_module }}" = "true" ]; then
                TF_ADDRESS="module.${TF_NAME}.azurerm_linux_virtual_machine.this[0]"

                VM_DATA=$(az vm show -g "$RG" -n "$RESOURCE_NAME" -o json)
                LOCATION=$(echo "$VM_DATA" | jq -r '.location')
                VM_SIZE=$(echo "$VM_DATA" | jq -r '.hardwareProfile.vmSize')
                TAGS=$(echo "$VM_DATA" | jq '.tags')

                CONFIG=$(cat <<EOF
          # IMPORTANTE: Este recurso usa el m√≥dulo virtual_machine del repositorio
          # Primero importa con: terraform import 'module.${TF_NAME}.azurerm_linux_virtual_machine.this[0]' $RESOURCE_ID
          # Luego ajusta la configuraci√≥n seg√∫n necesites

          module "$TF_NAME" {
            source = "./modules/virtual_machine"

            vm_name             = "$RESOURCE_NAME"
            resource_group_name = "$RG"
            location            = "$LOCATION"
            subnet_id           = "COMPLETAR_SUBNET_ID"  # Obtener con: az vm nic list

            os_type = "$([ "$RESOURCE_TYPE" = "virtual_machine_linux" ] && echo "linux" || echo "windows")"
            vm_size = "$VM_SIZE"

            # Usar imagen de Marketplace o source_image_id seg√∫n corresponda
            use_marketplace_image = true  # VERIFICAR
            marketplace_image = {
              publisher = "Canonical"  # VERIFICAR
              offer     = "0001-com-ubuntu-server-jammy"  # VERIFICAR
              sku       = "22_04-lts-gen2"  # VERIFICAR
              version   = "latest"
            }

            admin_username = "azureuser"  # ACTUALIZAR
            $([ "$RESOURCE_TYPE" = "virtual_machine_linux" ] && echo 'admin_ssh_keys = [
              {
                username   = "azureuser"
                public_key = file("~/.ssh/id_rsa.pub")  # ACTUALIZAR
              }
            ]' || echo 'admin_password = var.admin_password  # ACTUALIZAR')

            tags = $TAGS
          }
          EOF
          )
              else
                if [ "$RESOURCE_TYPE" = "virtual_machine_linux" ]; then
                  TF_ADDRESS="azurerm_linux_virtual_machine.${TF_NAME}"
                else
                  TF_ADDRESS="azurerm_windows_virtual_machine.${TF_NAME}"
                fi

                CONFIG=$(cat <<EOF
          # ADVERTENCIA: Esta configuraci√≥n es b√°sica y requiere ajustes manuales
          # Se recomienda usar use_module=true para VMs complejas

          resource "$([ "$RESOURCE_TYPE" = "virtual_machine_linux" ] && echo "azurerm_linux_virtual_machine" || echo "azurerm_windows_virtual_machine")" "$TF_NAME" {
            name                = "$RESOURCE_NAME"
            resource_group_name = "$RG"
            location            = "COMPLETAR"
            size                = "COMPLETAR"
            admin_username      = "COMPLETAR"

            network_interface_ids = [
              "COMPLETAR"  # Obtener con: az vm nic list
            ]

            os_disk {
              caching              = "ReadWrite"
              storage_account_type = "Premium_LRS"
            }

            # Completar seg√∫n imagen usada
            source_image_reference {
              publisher = "COMPLETAR"
              offer     = "COMPLETAR"
              sku       = "COMPLETAR"
              version   = "latest"
            }

            tags = {}
          }
          EOF
          )
              fi
              ;;

            *)
              echo "‚ùå Tipo de recurso no soportado: $RESOURCE_TYPE"
              exit 1
              ;;
          esac

          if [ -z "$RESOURCE_ID" ]; then
            echo "‚ùå No se pudo encontrar el recurso en Azure"
            exit 1
          fi

          echo "‚úÖ Recurso encontrado"
          echo "üìå Resource ID: $RESOURCE_ID"
          echo "üìå Terraform Address: $TF_ADDRESS"

          # Guardar outputs (escapar para JSON)
          {
            echo "resource_id=$RESOURCE_ID"
            echo "terraform_address=$TF_ADDRESS"
            echo 'resource_config<<EOF'
            echo "$CONFIG"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

          # Guardar para siguiente job
          echo "$CONFIG" > /tmp/config.tf

      - name: Upload config
        uses: actions/upload-artifact@v4
        with:
          name: terraform-config
          path: /tmp/config.tf
          retention-days: 1

  import:
    name: üì• Importar Recurso a Terraform
    needs: discover
    runs-on: ubuntu-latest
    environment: prd  # Requiere aprobaci√≥n

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Crear rama de import
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

          BRANCH="${{ needs.discover.outputs.branch_name }}"
          git checkout -b "$BRANCH"

      - name: Download config
        uses: actions/download-artifact@v4
        with:
          name: terraform-config
          path: /tmp

      - name: Agregar recurso a main.tf
        run: |
          # Agregar separador y recurso al final de main.tf
          cat >> main.tf <<EOF

          # ====================================================================
          # RECURSO IMPORTADO DESDE AZURE
          # Tipo: ${{ inputs.resource_type }} | Nombre: ${{ inputs.resource_name }}
          # Resource Group: ${{ inputs.resource_group }}
          # Importado: $(date -u +"%Y-%m-%d %H:%M:%S UTC") por ${{ github.actor }}
          # ====================================================================
          EOF

          cat /tmp/config.tf >> main.tf

          echo "üìù Recurso agregado a main.tf:"
          tail -30 main.tf

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: >
            {"clientId":"${{ secrets.AZURE_CLIENT_ID }}",
             "clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}",
             "subscriptionId":"${{ inputs.subscription_id }}",
             "tenantId":"${{ secrets.AZURE_TENANT_ID }}"}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init (with remote backend)
        run: |
          echo "üîß Inicializando Terraform con backend remoto..."

          terraform init -input=false \
            -backend-config="resource_group_name=terraform" \
            -backend-config="storage_account_name=xpeterraformpoc" \
            -backend-config="container_name=terraform-tfstate" \
            -backend-config="key=${{ needs.discover.outputs.branch_name }}.tfstate"

          echo "‚úÖ Terraform inicializado con backend remoto"

      - name: Terraform Import
        id: import
        run: |
          echo "üì• Importando recurso a Terraform..."
          echo ""
          echo "Terraform Address: ${{ needs.discover.outputs.terraform_address }}"
          echo "Azure Resource ID: ${{ needs.discover.outputs.resource_id }}"
          echo ""

          # Importar el recurso
          terraform import \
            ${{ needs.discover.outputs.terraform_address }} \
            "${{ needs.discover.outputs.resource_id }}"

          echo ""
          echo "‚úÖ Recurso importado exitosamente al state remoto"

      - name: Terraform Validate
        run: |
          echo "üîç Validando configuraci√≥n..."
          terraform validate

      - name: Terraform Plan
        id: plan
        continue-on-error: true
        run: |
          echo "üìä Ejecutando terraform plan..."
          terraform plan -out=tfplan -input=false

          # Convertir a JSON para an√°lisis
          terraform show -json tfplan > tfplan.json

          # Contar cambios
          CHANGES=$(jq -r '[.resource_changes[]? | select(.change.actions[] != "no-op")] | length' tfplan.json)

          echo "changes=$CHANGES" >> $GITHUB_OUTPUT

          if [ "$CHANGES" -eq 0 ]; then
            echo "‚úÖ Configuraci√≥n perfecta - No hay diferencias"
            echo "status=perfect" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  Configuraci√≥n requiere ajustes - $CHANGES cambios detectados"
            echo "status=needs_adjustment" >> $GITHUB_OUTPUT

            # Mostrar diferencias
            terraform show tfplan
          fi

      - name: Commit main.tf
        run: |
          git add main.tf

          # Mensaje de commit detallado
          cat > commit_msg.txt <<EOF
          feat: Import ${{ inputs.resource_type }} - ${{ inputs.resource_name }}

          Imported Azure resource to Terraform state

          Resource Details:
          - Type: ${{ inputs.resource_type }}
          - Name: ${{ inputs.resource_name }}
          - Resource Group: ${{ inputs.resource_group }}
          - Terraform Name: ${{ inputs.terraform_resource_name }}

          Import Status:
          - State: ‚úÖ Imported to remote backend
          - Plan: ${{ steps.plan.outputs.status }}
          - Changes Detected: ${{ steps.plan.outputs.changes }}

          Terraform Address: ${{ needs.discover.outputs.terraform_address }}
          Azure Resource ID: ${{ needs.discover.outputs.resource_id }}

          Imported by: @${{ github.actor }}
          Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF

          git commit -F commit_msg.txt
          git push origin "${{ needs.discover.outputs.branch_name }}"

          echo "‚úÖ C√≥digo commiteado y pusheado"

      - name: üìä Generar Summary
        if: always()
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          # ‚úÖ Recurso Importado a Terraform

          ## üìã Detalles del Recurso

          | Campo | Valor |
          |-------|-------|
          | **Tipo** | ${{ inputs.resource_type }} |
          | **Nombre en Azure** | ${{ inputs.resource_name }} |
          | **Resource Group** | ${{ inputs.resource_group }} |
          | **Nombre Terraform** | ${{ inputs.terraform_resource_name }} |
          | **Usar M√≥dulo** | ${{ inputs.use_module }} |

          ## üîß Estado de Importaci√≥n

          | Estado | Resultado |
          |--------|-----------|
          | **Recurso encontrado** | ‚úÖ Si |
          | **Importado al state** | ‚úÖ Si |
          | **Backend remoto** | ‚úÖ Azure Blob Storage |
          | **Terraform plan** | ${{ steps.plan.outputs.status }} |
          | **Cambios detectados** | ${{ steps.plan.outputs.changes }} |

          ## üìç Referencias

          - **Terraform Address:** `${{ needs.discover.outputs.terraform_address }}`
          - **Azure Resource ID:** `${{ needs.discover.outputs.resource_id }}`
          - **Rama creada:** `${{ needs.discover.outputs.branch_name }}`
          - **Archivo:** `main.tf`

          ## üìù Configuraci√≥n Generada

          ```hcl
          ${{ needs.discover.outputs.resource_config }}
          ```

          ## ‚è≠Ô∏è  Pr√≥ximos Pasos

          1. ‚úÖ El recurso ha sido importado al state remoto
          2. ‚úÖ La configuraci√≥n fue agregada a `main.tf` en la rama `${{ needs.discover.outputs.branch_name }}`
          3. ‚è≠Ô∏è  Haz pull de la rama para trabajar localmente:
             ```bash
             git fetch origin
             git checkout ${{ needs.discover.outputs.branch_name }}
             ```
          4. ‚è≠Ô∏è  Si el plan muestra diferencias (${{ steps.plan.outputs.changes }} cambios):
             - Ajusta la configuraci√≥n en `main.tf`
             - Ejecuta `terraform plan` hasta que no haya cambios
          5. ‚è≠Ô∏è  Crea un Pull Request para review y merge:
             ```bash
             gh pr create --title "Import ${{ inputs.resource_type }}: ${{ inputs.resource_name }}"
             ```

          EOF

          if [ "${{ steps.plan.outputs.status }}" = "needs_adjustment" ]; then
            cat << 'EOF' >> $GITHUB_STEP_SUMMARY

          ## ‚ö†Ô∏è  Ajustes Necesarios

          La configuraci√≥n generada no coincide exactamente con el recurso en Azure.
          Esto es **normal** y esperado. Debes ajustar manualmente:

          1. Revisa el output de `terraform plan` arriba
          2. Identifica las diferencias (valores computed, defaults, etc.)
          3. Ajusta `main.tf` seg√∫n sea necesario
          4. Ejecuta `terraform plan` localmente hasta obtener "No changes"

          **Valores comunes que requieren ajuste:**
          - IDs de recursos relacionados (subnet_id, vnet_id, etc.)
          - Contrase√±as y secretos (usa variables)
          - Configuraciones por defecto no expl√≠citas
          - Tags adicionales

          EOF
          fi

      - name: Crear Pull Request
        if: steps.plan.outputs.status == 'perfect'
        run: |
          gh pr create \
            --title "Import ${{ inputs.resource_type }}: ${{ inputs.resource_name }}" \
            --body "$(cat <<'EOFPR'
          ## üì• Import de Recurso Azure

          Este PR importa un recurso existente de Azure a Terraform.

          ### Recurso Importado

          - **Tipo:** ${{ inputs.resource_type }}
          - **Nombre:** ${{ inputs.resource_name }}
          - **Resource Group:** ${{ inputs.resource_group }}

          ### Validaci√≥n

          - ‚úÖ Recurso importado al state remoto
          - ‚úÖ Configuraci√≥n validada con `terraform plan`
          - ‚úÖ No hay diferencias detectadas

          ### Archivos Modificados

          - `main.tf` - Configuraci√≥n del recurso importado agregada

          ### Review Checklist

          - [ ] Revisar configuraci√≥n agregada en `main.tf`
          - [ ] Verificar que los valores sean correctos
          - [ ] Verificar tags y metadata
          - [ ] Aprobar y merge

          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOFPR
          )" \
            --head "${{ needs.discover.outputs.branch_name }}" \
            --base main
        env:
          GH_TOKEN: ${{ github.token }}
