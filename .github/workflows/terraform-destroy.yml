name: Terraform Destroy (solo por módulos)

on:
  workflow_dispatch:
    inputs:
      working_directory:
        description: "Carpeta con main.tf"
        default: "."
        required: true
      modules:
        description: "Nombres de módulos a destruir (uno por línea). Ej: network_security_group_2, virtual_machine_01"
        required: true
        default: |
          network_security_group_2

env:
  TF_IN_AUTOMATION: true
  ARM_TENANT_ID:     ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_ID:     ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_ACCESS_KEY:    ${{ secrets.ARM_ACCESS_KEY }}
  TF_VAR_admin_password: ${{ secrets.VM_PASSWORD }}

jobs:
  plan:
    name: Plan (destroy por módulos)
    runs-on: ubuntu-latest
    outputs:
      TARGET_ARGS: ${{ steps.build.outputs.TARGET_ARGS }}
    defaults:
      run:
        working-directory: ${{ github.event.inputs.working_directory }}

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          allow-no-subscriptions: true
          creds: >
            {"clientId":"${{ secrets.AZURE_CLIENT_ID }}",
             "clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}",
             "tenantId":"${{ secrets.AZURE_TENANT_ID }}"}

      - uses: hashicorp/setup-terraform@v3

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Terraform Init (tfstate por rama)
        run: |
          terraform init -input=false \
            -backend-config="resource_group_name=terraform" \
            -backend-config="storage_account_name=xpeterraformpoc" \
            -backend-config="container_name=terraform-tfstate" \
            -backend-config="key=${{ github.ref_name }}.tfstate"

      - name: Build targets (módulos → -target=module.<name>)
        id: build
        shell: bash
        run: |
          set -euo pipefail

          # Helpers
          trim() { sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//' -e '/^$/d'; }

          # Leer módulos desde input
          MODS_RAW='${{ github.event.inputs.modules }}'
          mapfile -t MODS < <(printf "%s" "$MODS_RAW" | tr '\r' '\n' | trim)

          if [ ${#MODS[@]} -eq 0 ]; then
            echo "❌ No se proporcionaron módulos." >&2
            exit 1
          fi

          # Listado del state para validar existencia de cada módulo
          echo "Leyendo tfstate para validación…"
          terraform state pull > state.json
          # Construir un set de prefijos de módulo presentes en el state (p.ej. module.network_security_group_2)
          mapfile -t STATE_ADDRS < <(jq -r '
            [.resources[]?.module] | map(select(.!=null)) | unique[]' state.json)

          # Función que verifica si algún address del state comienza con "module.<mod>."
          module_in_state () {
            local mod="module.$1"
            for m in "${STATE_ADDRS[@]}"; do
              if [[ "$m" == "$mod" ]]; then
                return 0
              fi
            done
            # fallback: si no hay "module" entries (recursos en root), intentar por si acaso via terraform state list
            return 1
          }

          TARGETS=()
          echo "Validando módulos:"
          for m in "${MODS[@]}"; do
            m_clean="$(echo "$m" | tr -d '"' | tr -d "'")"
            [ -z "$m_clean" ] && continue
            if module_in_state "$m_clean"; then
              echo "  ✅ $m_clean"
              TARGETS+=("-target=module.$m_clean")
            else
              # También probar con terraform state list (por si hay recursos que no aparecen en .module del pull)
              if terraform state list | grep -q "^module\.${m_clean}\." ; then
                echo "  ✅ $m_clean (por state list)"
                TARGETS+=("-target=module.$m_clean")
              else
                echo "  ⚠️  Módulo no encontrado en el state: $m_clean"
              fi
            fi
          done

          if [ ${#TARGETS[@]} -eq 0 ]; then
            echo "❌ Ningún módulo coincide con el tfstate. Revisa los nombres (ej: 'network_security_group_2')." >&2
            echo "Sugerencia: ejecuta 'terraform state list' localmente y copia el prefijo después de 'module.'."
            exit 1
          fi

          printf -v TARGET_ARGS "%s " "${TARGETS[@]}"
          echo "TARGET_ARGS=$TARGET_ARGS" >> "$GITHUB_OUTPUT"
          echo "Targets finales: $TARGET_ARGS"

      - name: Plan (destroy targeted)
        run: |
          terraform plan -destroy -input=false \
            ${{ steps.build.outputs.TARGET_ARGS }} \
            -out=tfplan-destroy

      - name: Resumen de lo que se eliminará
        run: |
          terraform show -json tfplan-destroy > plan.json
          echo "## Recursos a eliminar (según plan)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Tipo | Nombre | RG | Address |" >> "$GITHUB_STEP_SUMMARY"
          echo "|------|--------|----|---------|" >> "$GITHUB_STEP_SUMMARY"
          jq -r '
            (.resource_changes // [])
            | map(select(.change.actions|index("delete")))
            | .[]
            | {
                t: .type,
                n: (.change.before.name // .change.after.name // .name // "(sin-name)"),
                rg:(.change.before.resource_group_name // .change.before.resource_group // "(n/a)"),
                a: .address
              }
            | "| \(.t) | \(.n) | \(.rg) | `\(.a)` |"
          ' plan.json >> "$GITHUB_STEP_SUMMARY"

      - name: Publicar plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-destroy
          path: tfplan-destroy

  approve:
    name: Aprobación requerida
    environment: prd   # protege este environment con reviewers
    runs-on: ubuntu-latest
    needs: plan
    steps:
      - run: echo "Revisa el Summary del job 'Plan' (tabla de recursos a eliminar) y aprueba para continuar."

  destroy:
    name: Destroy (aprobado)
    runs-on: ubuntu-latest
    needs: [plan, approve]
    defaults:
      run:
        working-directory: ${{ github.event.inputs.working_directory }}

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          allow-no-subscriptions: true
          creds: >
            {"clientId":"${{ secrets.AZURE_CLIENT_ID }}",
             "clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}",
             "tenantId":"${{ secrets.AZURE_TENANT_ID }}"}

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init (tfstate por rama)
        run: |
          terraform init -input=false \
            -backend-config="resource_group_name=terraform" \
            -backend-config="storage_account_name=xpeterraformpoc" \
            -backend-config="container_name=terraform-tfstate" \
            -backend-config="key=${{ github.ref_name }}.tfstate"

      - name: Destroy (mismos targets del plan)
        run: |
          terraform destroy -input=false -auto-approve \
            ${{ needs.plan.outputs.TARGET_ARGS }}
